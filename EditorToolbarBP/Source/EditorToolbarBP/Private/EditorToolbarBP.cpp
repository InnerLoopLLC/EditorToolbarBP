// Copyright Epic Games, Inc. All Rights Reserved.

#include "EditorToolbarBP.h"
#include "EditorToolbarBPStyle.h"
#include "EditorToolbarBPCommands.h"
#include "Misc/MessageDialog.h"
#include "ToolMenus.h"
#include "EditorToolbarBPActor.h"
#include "Engine/Selection.h"
#include "Kismet2/KismetEditorUtilities.h"

DEFINE_LOG_CATEGORY(LogEditorToolbarBP);

static const FName EditorToolbarBPTabName("EditorToolbarBP");

#define LOCTEXT_NAMESPACE "FEditorToolbarBPModule"

void FEditorToolbarBPModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
	
	FEditorToolbarBPStyle::Initialize();
	FEditorToolbarBPStyle::ReloadTextures();

	// Make events visible in the actor by default, but disabled until used.
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction1));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction2));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction3));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction4));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction5));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction6));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction7));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction8));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction9));
	FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, AEditorToolbarBPActor::StaticClass(), GET_FUNCTION_NAME_CHECKED(AEditorToolbarBPActor, ToolbarAction10));

	// Register menu commands
	FEditorToolbarBPCommands::Register();

	// Create the command list
	CreateCommandList();

	// Register Menus
	UToolMenus::RegisterStartupCallback(FSimpleMulticastDelegate::FDelegate::CreateRaw(this, &FEditorToolbarBPModule::RegisterMenus));
}

void FEditorToolbarBPModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.

	// Unregister the default blueprint events
	FKismetEditorUtilities::UnregisterAutoBlueprintNodeCreation(this);

	UToolMenus::UnRegisterStartupCallback(this);

	UToolMenus::UnregisterOwner(this);

	FEditorToolbarBPStyle::Shutdown();

	FEditorToolbarBPCommands::Unregister();
}

void FEditorToolbarBPModule::ToolbarAction(uint8 ActionNumber)
{
	// Junk function. At least for now.

	/*
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				switch (ActionNumber)
				{
				case 1:
					ActorItr->ToolbarAction1();
					UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 1."));
					break;
				case 2:
					ActorItr->ToolbarAction2();
					UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 1."));
					break;
				default:
					break;
				}
			}
		}
	}
	*/
}

void FEditorToolbarBPModule::ToolbarAction1()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction1();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 1."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction2()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction2();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 2."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction3()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction3();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 3."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction4()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction4();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 4."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction5()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction5();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 5."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction6()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction6();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 6."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction7()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction7();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 7."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction8()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction8();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 8."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction9()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction9();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 9."));
			}
		}
	}
}

void FEditorToolbarBPModule::ToolbarAction10()
{
	// Disable action if PIE or SIE
	if (!GEditor->IsPlaySessionInProgress())
	{
		// Get all uobjects, either in the level or if a blueprint editor is open.
		for (TObjectIterator<AEditorToolbarBPActor> ActorItr; ActorItr; ++ActorItr)
		{
			// Only consider objects if the actor is placed in the editor world. If not, then ignore it. 
			// Objects open in a blueprint editor will be ignored.
			if (ActorItr->GetWorld() == GEditor->GetEditorWorldContext().World())
			{
				ActorItr->ToolbarAction10();
				UE_LOG(LogEditorToolbarBP, Log, TEXT("Executed event Toolbar Action 10."));
			}
		}
	}
}

void FEditorToolbarBPModule::CreateCommandList()
{
	// Create the command list
	PluginCommands = MakeShareable(new FUICommandList);

	// Map actions to the command list
	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[0],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction1), 
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[1],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction2),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[2],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction3),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[3],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction4),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[4],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction5),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[5],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction6),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[6],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction7),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[7],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction8),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[8],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction9),
		FCanExecuteAction());

	PluginCommands->MapAction(
		FEditorToolbarBPCommands::Get().ToolbarAction[9],
		FExecuteAction::CreateRaw(this, &FEditorToolbarBPModule::ToolbarAction10),
		FCanExecuteAction());
}

void FEditorToolbarBPModule::RegisterMenus()
{
	// Owner will be used for cleanup in call to UToolMenus::UnregisterOwner
	FToolMenuOwnerScoped OwnerScoped(this);

	/*
	// This section doesn't seem necessary at the moment. Will worry about it more in the next update, while focusing on appearance
	{
		UToolMenu* Menu = UToolMenus::Get()->ExtendMenu("LevelEditor.MainMenu.Window");
		{
			FToolMenuSection& Section = Menu->FindOrAddSection("WindowLayout");
			Section.AddMenuEntryWithCommandList(FEditorToolbarBPCommands::Get().OpenActionList, PluginCommands);
		}
	}
	*/

	{
		UToolMenu* ToolbarMenu = UToolMenus::Get()->ExtendMenu("LevelEditor.LevelEditorToolBar");
		{
			FToolMenuSection& Section = ToolbarMenu->FindOrAddSection("Settings");
			{
				FToolMenuEntry& Entry1 = Section.AddEntry(FToolMenuEntry::InitToolBarButton(FEditorToolbarBPCommands::Get().ToolbarAction[0]));
				Entry1.SetCommandList(PluginCommands);
				FToolMenuEntry& Entry2 = Section.AddEntry(FToolMenuEntry::InitToolBarButton(FEditorToolbarBPCommands::Get().ToolbarAction[1]));
				Entry2.SetCommandList(PluginCommands);
			}
		}
	}
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FEditorToolbarBPModule, EditorToolbarBP)

/*
	// Gets the world. Compare it to the actor.
	GEditor->GetEditorWorldContext();
	GEditor->GetPIEWorldContext();

	// Returns true if blueprint graph is currently open for this class
	FKismetEditorUtilities::GetIBlueprintEditorForObject(ActorItr->GetClass(), false)
*/